#!/usr/bin/env python3
import rospy
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
import math

# Goal coordinate
goal_x = 3.0
goal_y = 8.0

# Propertional Gains
LIN_GAIN = 0.5      # linear velocity = LIN_GAIN * distance
ANG_GAIN = 2.0      # angular velocity = ANG_GAIN * angle_error

# Safety limits so the turtle doesn't move very fast
MAX_LIN = 1.5
MAX_ANG = 2.0

# Goal Threshold
GOAL_TOLERANCE = 0.1

def normalize_angle(angle):
    return math.atan2(math.sin(angle), math.cos(angle))

def pose_callback(msg: Pose):
    dx = goal_x - msg.x
    dy = goal_y - msg.y

    distance = (YOUR CODE HERE)
    angle_to_goal = (YOUR CODE HERE)

    # normalized angular error in [-pi, pi]
    angle_error = normalize_angle(angle_to_goal - msg.theta)
		
    # Define the msg for command
    cmd = (YOUR CODE HERE)

    # If we're nearly facing the goal, move forward; otherwise rotate in place
    if abs(angle_error) > 0.2:
        # Turn to face the goal first
        cmd.linear.x = (YOUR CODE HERE)
        cmd.angular.z = (YOUR CODE HERE)
    else:
        # Move forward while fine-tuning heading
        cmd.linear.x = (YOUR CODE HERE)
        # Fine tune the angle a bit while moving
        cmd.angular.z = ANG_GAIN * angle_error

    # Clamp velocities to safe values
    if cmd.linear.x > MAX_LIN:
        cmd.linear.x = MAX_LIN
    if cmd.linear.x < 0.0:
        cmd.linear.x = 0.0

    if cmd.angular.z > MAX_ANG:
        cmd.angular.z = MAX_ANG
    if cmd.angular.z < -MAX_ANG:
        cmd.angular.z = -MAX_ANG
		
    # Publish the command
    (YOUR CODE HERE)

    # Stop when close enough
    if distance < GOAL_TOLERANCE:
        pub.publish(Twist())  
        rospy.loginfo("Goal reached at x=%.2f y=%.2f", msg.x, msg.y)
        rospy.signal_shutdown("Goal reached")

if __name__ == "__main__":
    rospy.init_node("go_to_point_simple")
    pub = rospy.Publisher("/turtle1/cmd_vel", Twist, queue_size=10)
    sub = rospy.Subscriber("/turtle1/pose", Pose, pose_callback)
    rospy.spin()
